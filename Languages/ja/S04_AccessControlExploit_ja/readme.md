---
title: S04. アクセス制御脆弱性
tags:
  - solidity
  - security
  - modifier
  - erc20
---

# WTF Solidity 合約セキュリティ: S04. アクセス制御脆弱性

私は最近Solidityを学び直して詳細を固めており、「WTF Solidity 合約セキュリティ」を書いています。初心者向けの内容で（プログラミング上級者は他のチュートリアルをお探しください）、毎週1-3講座を更新しています。

Twitter：[@0xAA_Science](https://twitter.com/0xAA_Science)｜[@WTFAcademy_](https://twitter.com/WTFAcademy_)

コミュニティ：[Discord](https://discord.gg/5akcruXrsk)｜[微信群](https://docs.google.com/forms/d/e/1FAIpQLSe4KGT8Sh6sJ7hedQRuIYirOoZK_85miz3dw7vA1-YjodgJ-A/viewform?usp=sf_link)｜[公式サイト wtf.academy](https://wtf.academy)

すべてのコードとチュートリアルはgithubでオープンソース化されています：[github.com/AmazingAng/WTF-Solidity](https://github.com/AmazingAng/WTF-Solidity)

---

今回は、スマートコントラクトのアクセス制御脆弱性について紹介します。この脆弱性により、クロスチェーンブリッジPoly Networkが6.11億ドルを盗まれ、BSC上のDeFiプロジェクトShadowFiが$300,000を盗まれました。

## アクセス制御脆弱性

スマートコントラクトにおけるアクセス制御は、アプリケーション内での異なる役割の権限を定義します。通常、トークンのミント、資金の引き出し、一時停止などの機能は、高い権限を持つユーザーのみが呼び出すことができます。アクセス制御の設定が間違っていると、予期しない損失を引き起こす可能性があります。以下では、2つの一般的なアクセス制御脆弱性を紹介します。

### 1. アクセス制御設定エラー

コントラクト内の特別な機能にアクセス制御が設定されていない場合、誰でも大量のトークンをミントしたり、コントラクト内の資金を引き出したりすることができます。クロスチェーンブリッジPoly Networkのコントラクトでは、ガーディアンを変更する関数に適切なアクセス制御が設定されておらず、ハッカーが自分のアドレスに変更し、コントラクトから6.11億ドルを引き出すことができました。

以下のコードでは、`mint()`関数にアクセス制御が設定されていないため、誰でもこれを呼び出してトークンをミントできます。

```solidity
// 間違ったmint関数、アクセス制御が制限されていない
function badMint(address to, uint amount) public {
    _mint(to, amount);
}
```

![](./img/S04-1.png)

### 2. 認可チェックエラー

もう一つの一般的なアクセス制御脆弱性は、関数内で呼び出し元が十分な認可を持っているかをチェックしていないことです。BSC上のDeFiプロジェクトShadowFiのトークンコントラクトは、`burn()`バーン関数で呼び出し元の認可額をチェックし忘れ、攻撃者が他のアドレスのトークンを任意にバーンできる状況を生み出しました。ハッカーが流動性プール内のトークンをバーンした後、少量のトークンを売却するだけでプール内のすべての`BNB`を引き出すことができ、$300,000の利益を得ました。

```solidity
// 間違ったburn関数、アクセス制御が制限されていない
function badBurn(address account, uint amount) public {
    _burn(account, amount);
}
```

![](./img/S04-2.png)

## 予防方法

アクセス制御脆弱性には主に2つの予防方法があります：

1. Openzeppelinのアクセス制御ライブラリを使用して、コントラクトの特別な関数に適切なアクセス制御を設定する。例えば、`OnlyOwner`モディファイアを使用して、コントラクト所有者のみが呼び出せるようにします。

  ```solidity
  // 正しいmint関数、onlyOwner モディファイアでアクセス制御を制限
  function goodMint(address to, uint amount) public onlyOwner {
      _mint(to, amount);
  }
  ```

2. 関数のロジック内で、コントラクト呼び出し元が十分な認可を持っていることを確認する。

  ```solidity
  // 正しいburn関数、自分以外のトークンをバーンする場合は認可をチェック
  function goodBurn(address account, uint amount) public {
      if(msg.sender != account){
          _spendAllowance(account, msg.sender, amount);
      }
      _burn(account, amount);
  }
  ```

## まとめ

今回は、スマートコントラクトにおけるアクセス制御脆弱性について紹介しました。主に2つの形式があります：アクセス制御設定エラーと認可チェックエラーです。この類の脆弱性を避けるために、アクセス制御ライブラリを使用して特別な関数に適切なアクセス制御を設定し、関数のロジック内でコントラクト呼び出し元が十分な認可を持っていることを確認する必要があります。